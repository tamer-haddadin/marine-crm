here is the soultion

Problem Analysis:

Server Response Structure: The server's PUT endpoint for updating an order might not return the complete updated Order object. If it returns a success message or a partial object, the client's optimistic update using response.order will be incorrect.

Data Type Mismatch: The premium field might be sent as a string from the client but returned as a number from the server. The client's select function in OrderList converts it to a string, but during optimistic updates (before invalidation), the UI might display the number without formatting.

Solution:

Ensure Server Returns the Full Updated Order:
Confirm that the server's PUT /api/orders/{id} endpoint returns the complete updated Order object (including all fields like premium, insuredName, etc.). If the response is nested (e.g., { data: Order }), adjust the client to use response.data.

Before (if response is nested):

const responseData = await res.json();
return responseData;

After:

const responseData = await res.json();
return responseData.data; // If the server nests the order under `data`

Handle Premium Data Type in Client:
Ensure the premium field is consistently treated as a string in the client to avoid formatting issues.

In EditOrderDialog's handleSuccess, explicitly convert premium to a string during the optimistic update:

// Inside setQueryData:
return oldData.map(order => 
  order.id === response.order.id ? { 
    ...response.order, 
    premium: String(response.order.premium) 
  } : order
);

Remove redundant select in OrderList's useQuery to avoid duplication if the server already returns premium as a string.

// Remove the select function in OrderList's useQuery:
useQuery<Order[]>({
  queryKey: ["/api/orders"],
  // ... other options
});

Debugging Steps:

Check the network response in the browser's DevTools to verify the server's PUT response.

Log response.order in handleSuccess to ensure it contains all updated fields.

Modified Code Snippets:

In order-form.tsx's updateOrderMutation, ensure handling of response data:

const updateOrderMutation = useMutation({
  mutationFn: async (data: any) => {
    // ... existing code
    const res = await apiRequest("PUT", `/api/orders/${initialData?.id}`, formData);
    if (!res.ok) {
      // ... error handling
    }
    const responseData = await res.json();
    // Adjust if the server nests the order in a `data` property
    return responseData.data ? responseData.data : responseData;
  },
  // ... rest of the code
});

In edit-order-dialog.tsx, update the optimistic cache setter:

queryClient.setQueryData(["/api/orders"], (oldData: Order[] | undefined) => {
  if (!oldData) return [response.order];
  return oldData.map(order => 
    order.id === response.order.id ? { 
      ...response.order,
      premium: String(response.order.premium) // Convert premium to string
    } : order
  );
});

