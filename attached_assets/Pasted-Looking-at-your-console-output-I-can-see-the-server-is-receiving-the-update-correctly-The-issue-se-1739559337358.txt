Looking at your console output, I can see the server is receiving the update correctly. The issue seems to be with how the data is being handled in the UI after the update. Let's fix this:

First, modify the OrderList.tsx component's query to ensure it's not caching stale data:

const { data: orders, isLoading } = useQuery<Order[]>({
    queryKey: ["/api/orders"],
    staleTime: 0,
    cacheTime: 0,
    refetchOnMount: true,
    refetchOnWindowFocus: true,
});

Then, update the handleEditSuccess function in OrderList.tsx:

const handleEditSuccess = async (response: { order: Order; hasMovedToClosed: boolean }) => {
    try {
        // Immediately update the cache with the new order data
        queryClient.setQueryData(["/api/orders"], (oldData: Order[] | undefined) => {
            if (!oldData) return [response.order];
            return oldData.map(order => 
                order.id === response.order.id ? response.order : order
            );
        });

        // Force an immediate refetch
        await queryClient.invalidateQueries({ queryKey: ["/api/orders"], refetchType: 'active' });
        
        setEditingOrder(null); // Close the dialog

        if (response.hasMovedToClosed) {
            toast({
                title: "Order Status Updated",
                description: "The order has been moved to Closed Policies.",
            });
            setTimeout(() => setLocation("/closed-policies"), 1500);
        }
    } catch (error) {
        console.error('Failed to update orders:', error);
        toast({
            title: "Error",
            description: "Failed to refresh the order list. Please refresh the page.",
            variant: "destructive",
        });
    }
};

Update the updateOrderMutation in OrderForm.tsx:

const updateOrderMutation = useMutation({
    mutationFn: async (data: any) => {
        const formData = {
            ...data,
            orderDate: new Date(data.orderDate).toISOString(),
            premium: String(data.premium),
            notes: data.notes || null,
        };
        
        console.log('Sending update with data:', formData); // Debug log
        
        const res = await apiRequest("PUT", `/api/orders/${initialData?.id}`, formData);
        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || 'Failed to update order');
        }
        const responseData = await res.json();
        return responseData;
    },
    onSuccess: (response) => {
        // Force cache update
        queryClient.setQueryData(["/api/orders"], (oldData: Order[] | undefined) => {
            if (!oldData) return [response];
            return oldData.map(order => 
                order.id === response.id ? response : order
            );
        });

        toast({
            title: "Success",
            description: "Firm order updated successfully",
        });

        onSuccess({ order: response, hasMovedToClosed: false });
    },
    onError: (error: Error) => {
        console.error('Order update error:', error);
        toast({
            title: "Error",
            description: error.message,
            variant: "destructive",
        });
    },
});

Also, ensure the premium display in the table is properly formatted:

<TableCell>
    {Number(order.premium).toFixed(2)} {order.currency}
</TableCell>

These changes should:

Prevent caching of stale data
Force immediate updates to the UI when changes occur
Ensure proper number formatting for the premium
Add additional error handling and logging

The key changes are:

Disabling stale data caching
Adding immediate cache updates
Forcing refetches after updates
Ensuring proper data transformation

This should fix the issue where premium and other fields aren't updating in the UI immediately after changes.